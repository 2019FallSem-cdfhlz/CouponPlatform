# 性能测试

## 1. 单元测试

在完成基本的开发代码编写后，我们需要进行单元测试。单元测试是指对软件或项目中最小可测试单元进行正确性检验的测试工作，是一个项目开发过程中非常重要的一环。基本的单元测试，可以在系统测试之前，将大部分比较低级的错误查找出来，减少系统测试过程中的问题，这样也就减少了系统测试中定位和解决问题的时间成本。

### 1.1 单元测试分析

我们将单元测试分为了用户部分和优惠券部分。具体细分如下：

- 用户
  - 注册
  - 登录
- 优惠券
  - 商家创建优惠券
  - 商家不可以创建重复的优惠券
  - 用户不可以创建优惠券
  - 用户获取优惠券
  - 用户获取优惠券信息空页时返回204状态码
  - 用户不能获取同一种优惠券两次

我们简单地来分析用户部分的单元测试代码，如下：

``` javascript
describe('用户', () => {
  it('用户注册并登录', async () => {
    const result = await req.post(`/users`, {
      body: {
        username: 'test1',
        password: '123456',
        kind: 'saler'
      }
    })

    result.statusCode.should.be.eql(201, '注册成功')

    ;(await req.post(`/auth`, { body: { username: 'test1', password: '123456' } })).statusCode.should.be.eql(200, '登录成功')
  })
})
```

可以看到，用户注册和登录所使用的HTTP请求均为post。模拟商家test1的注册和登录行为，通过判断HTTP响应的状态码是否为200，来判断单元测试的结果是否正确。优惠券部分的代码也类似，通过提交HTTP请求，根据响应内容的状态码或者返回信息的具体内容来测试结果的正确性。

### 1.2 单元测试结果

下面展示的是单元测试的结果。可以看出，我们的优惠券服务器所有的基本功能执行正确。

![pic1.jpeg](https://upload-images.jianshu.io/upload_images/8636110-0df0a1a4f7a85c2f.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

通过单元测试的模块，我们也对每个接口的正确性做出了验证，从而有利于后续在进行性能优化的同时，也保证了应用接口的正确性。

## 2. 性能测试过程与分析

在性能测试的一开始时，我们在并发量达到2000时就达到了性能瓶颈，经过分析后，发现造成该并发瓶颈的主要原因是由于TCP连接本身造成的：TCP四次挥手，在最后关闭的时候连接会处于TIME_WAIT状态，要等到两个MSL之后连接才会释放。因此，我们在容器开启了TCP重用，从而使得网络并发量可以达到4000以上。TCP重用能够使得处于TIME_WAIT的连接可直接重用，从而减少了网络等待的开销。

由于需要对服务器本身的性能进行测试与调优，我们进行了多种方式的迭代。具体的实验结果以折线图的方式给出，其中，横轴的步长指的就是请求并发量，而纵轴则表示用户平均响应时间，以毫秒为单位。

（1）最简单的选择是单节点单数据库模式，其表现如下：

![image.png](https://upload-images.jianshu.io/upload_images/8636110-46596524381c4b63.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

其实，一般情况下，用户响应时间和并发量应该是成正比的，但实际情况是响应时间呈周期性波动变化，包括之后的不同的实验设置也存在着相同的情况。比如从1000->1200，或者1200->1400时响应时间有所下降；而2200->2400也存在这种下降等等。

我们猜测，响应时间的下降主要是由于在这些时间点恰好有一批TCP连接被释放，所以导致响应时间会有所降低；然后随着新的TCP连接建立，用户响应时间又会上升。

（2）接下来，我们考虑利用分布式存储达到冗余存储的功能，从而增加了主从模式。具体表现如下：

![image.png](https://upload-images.jianshu.io/upload_images/8636110-6eb34c05e8982920.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![image.png](https://upload-images.jianshu.io/upload_images/8636110-b3b97cb5f1ecf30a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

可以发现，1主3从的用户平均响应时间要高于1主1从的模式，并且在用户平均响应时间方面与原先的1node1db方式相比，并没有显著的改善。

因此经过我们的分析，发现在单机器上做分布式存储的意义并不大，并且在分布式数据库之间的通信也需要消耗额外的TCP连接等等。冗余存储可以保障可用性，但同时也会带来额外的IO开销。总结到一点，如果要提高并发量，就需要尽量减少多余的网络开销，因此我们在之后的实验设置中就不考虑分布式数据库的方式了。

（3）接下来的实验设置，我们一开始考虑用nginx来做负载均衡，但考虑到单机的CPU核数限制，而nginx至少需要占一个核，因此将此方案排除；因此，我们使用了pm2来做负载均衡。我们采用了单数据库，另外在一个容器里使用pm2启动3个node进程，其实验结果如下：

![image.png](https://upload-images.jianshu.io/upload_images/8636110-28bcb321d9550003.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

与前面的几种实验设置对比，可以明显发现，使用pm2做负载均衡后，在用户平均响应时间的动荡明显要小了不少，同时用户平均响应时间实际上也有所减少。因此之后，我们会采取用pm2做负载均衡，并且采取单容器单数据库形式，从而减少了额外的网络开销。

（4）在前面实验的基础上，我们考虑将高并发的持久化操作通过消息队列缓存起来，通过合并操作来提高使用率，同时用Redis作为缓存加速数据的读取，仍使用单数据库，单缓存，单消息队列，队列容量为200，处理周期为3000ms，分别测试了2-4个node进程的并发性能，实验结果如下：
