## 代码分析

由于我们所使用的脚手架在多数应用中可以复用，核心的开发部分主要专注于模型(model)和路由(route)部分，我们在这两部分主要实现了数据库的Schema设计以及接口文档中要求的Web API，还有进行身份认证

### 模型实现



### 路由实现

#### 身份认证

* 分析: 用户登录后，后续的请求都需要携带身份凭据，由于在每个路由中单独去进行身份验证会造成大量冗余，故需将身份认证部分单独提取出来作为一层中间件，放在所有路由的前面。
* 代码实现:
```Javascript
router.use(jwt({ secret: config.secret }).unless({
  path: [
    /^\/api\/auth$/,
    /^\/api\/users$/
  ]
}))
```

#### 用户注册

* 接口: POST /api/users
* 状态码:
```Javascript
{
    201: 注册成功
    400: 用户名已被占用
}
```
* 分析: 该接口需要从请求体中读取数据，并在数据库中检查用户名是否被占用，否则返回相应的错误信息给用户，同时要保证用户提交数据的正确性，即`kind`字段必须是`'customer'`或者`'saler'`，若所有的检查都通过，就将用户提交的密码经过MD5散列后将用户信息存储在数据库中。
* 代码实现
```Javascript
/**
 * 用户注册接口
 * @param username {String} 用户名
 * @param password {String} 密码
 * @param kind {String} 用户类型，必须是'saler'和'customer'其中之一
 */
router.post('/users', async (ctx, next) => {
  const { username, password, kind } = ctx.request.body

  if (kind !== 'saler' && kind !== 'customer') 
    throw new InvalidUserInputError('Kind field must be \'customer\' or \'saler\'')
  if (await User.findById(username)) throw new InvalidUserInputError('用户名已被占用')

  await new User({ _id: username, kind: (kind === 'saler' ? 1 : 0) , password: md5(password) }).save()

  ctx.status = 201
  ctx.result = emptyResponse
  return next()
})
```

#### 用户登录

* 接口: POST /api/auth
* 状态码: 
```Javascript
{
    200: 登录成功，响应体头部的Authorization字段会携带token
    401: 用户名或密码错误
}
```
* 响应: { kind } 用户类型，'saler'表示商家，'customer'表示用户
* 分析: 该接口需要从请求体中读取用户名和密码后，将密码进行MD5散列，然后在数据库中匹配相应的条目，若无匹配结果则说明用户名或密码不匹配，抛出相应异常(401)。否则，需要将用户名与用户类型经JsonWebToken加密，然后添加到响应头的`authorization`字段中，作为用户后续登录需要携带的身份凭据，有效期一小时。
* 代码实现:
```Javascript
/**
 * @param username {String} 用户名
 * @param password {String} 密码
 * @responseHeader authorization 用户认证的token，有效期一小时
 */
router.post('/auth', async (ctx, next) => {
  const { username, password } = ctx.request.body

  const result = await User.findOne({ _id: username, password: md5(password) })
  if (!result) throw new AuthorizationError('Authorization error')

  const token = ${jwt.sign({ sub: result._id, kind: result.kind }, config.secret, { expiresIn: '1 hours' })}
  ctx.append('Authorization', `Bearer ${token}`)
  ctx.status = 200
  ctx.result = { kind: result.kind ? 'saler' : 'customer' }
  return next()
})
```

#### 新建优惠券

* 接口: POST /api/users/{username}/coupons
* 状态码:
```Javascript
{
  201: 创建成功,
  400: 创建用户原因导致的创建失败或其他问题,
  401: 认证失败
}
```
* 分析: 该接口只有商家可以调用，且URL中的用户名必须与token中的用户名一致，所以需要进行两次检查，否则抛出相应的异常(400或401)，
* 代码实现:
```Javascript
/**
 * @param uid {String} 创建者的用户名
 * @param name {String} 优惠券名称
 * @param amount {Number} 优惠券数量
 * @param description {String} 优惠券信息
 * @param stock {Number} 优惠券面额
 */
router.post('/users/:uid/coupons', async (ctx, next) => {
  const { uid } = ctx.params
  const { sub, kind } = ctx.state.user

  if (sub !== uid) throw new AuthorizationError('Authorization error');
  if (!kind) throw new InvalidUserInputError('You\'re not a saler')

  const { name, amount, description, stock } = ctx.request.body
  await new Coupon({
    username: uid,
    name,
    amount,
    left: amount,
    description,
    stock
  }).save()

  ctx.status = 201
  ctx.result = emptyResponse
  return next()
})
```